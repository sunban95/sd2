<!doctype html>
<html lang="en">
<head>
	<title>SAMSUNG DEVELOPERS</title>
	<meta charset="utf-8" />
	<link rel="stylesheet" type="text/css" href="/common/css/common.css" />
	<link rel="stylesheet" type="text/css" href="/common/css/layout.css" />
	<link rel="stylesheet" type="text/css" href="/common/css/content.css" />
	<link rel="stylesheet" type="text/css" href="/common/css/services.css" />
	<link rel="stylesheet" type="text/css" href="/common/css/prism.css" />
	<script type="text/javascript" src="/common/js/lib/jquery-1.9.1.min.js"></script>
	<script type="text/javascript" src="/common/js/lib/jquery.easing.1.3.js"></script>
	<script type="text/javascript" src="/common/js/lib/prism.js"></script>
	<!-- Import common templates -->
	<!-- ***** 퍼블리싱 제작을 위한 단순 HTML 페이지를 불러오는 기능으로 실제 구현시 프로젝트에 해당되는 방법으로 Include 해야합니다. ***** -->
	<script type="text/javascript">
		//<![CDATA[
		$(document).ready(function(){
			jQuery.ajaxSetup({async:false}); // Sync를 불러와서 실제 Include 효과
			$("#sd2_partial_gnb_1").load("/common/partials/gnb_1.html?v="+(new Date()).getTime());
			$("#sd2_partial_gnb_2").load("/common/partials/gnb_2.html?v="+(new Date()).getTime());
			$("#sd2_partial_lnb").load("/common/partials/lnb_service.html?v="+(new Date()).getTime());
			$("#sd2_partial_footer").load("/common/partials/footer.html?v="+(new Date()).getTime());
			jQuery.ajaxSetup({async:true});
		});
		// ]]>
	</script>
	<!-- //Import common templates -->
	<script type="text/javascript" src="/common/js/gnb.js"></script>
	<script type="text/javascript" src="/common/js/lnb.js"></script>
	<script type="text/javascript" src="/common/js/content.js"></script>
</head>
<body>
<!-- wrap -->
<div id="sd2_wrap">
	<!-- ***** IMPORT: sd2_partial_gnb_1 ***** -->
	<div id="sd2_partial_gnb_1"></div>
	<!-- //***** IMPORT: sd2_partial_gnb_1 ***** -->
	<!-- header_2_wrap -->
	<div class="sd2_header_2_wrap">
		<!-- ***** IMPORT: sd2_partial_gnb_2 ***** -->
		<div id="sd2_partial_gnb_2"></div>
		<!-- //***** IMPORT: sd2_partial_gnb_2 ***** -->
	</div><!-- //header_2_wrap -->
	<!-- content_wrap -->
	<div class="sd2_content_wrap">
		<!-- ***** IMPORT: sd2_partial_lnb ***** -->
		<div id="sd2_partial_lnb"></div>
		<!-- //***** IMPORT: sd2_partial_lnb ***** -->
		<!-- substance_wrap -->
		<div class="sd2_substance_wrap sd2_mb_40">
			<!-- location -->
			<div class="sd2_location sd2_con_margin">
				<ol>
					<li><a href="/02_services/services/services_services.html">SERVICES</a></li>
					<li><a href="/02_services/in-app/services_in-app.html">Samsung In-App Purchase</a></li>
					<li class="sd2_now"><a href="#">In App Content</a></li>
				</ol>
			</div><!-- //location -->
			<!-- page_title -->
			<div class="sd2_page_title sd2_con_margin">
				<h3>In App Content <span class="sd2_page_title_side">Sep 12, 2013</span></h3>
			</div><!-- //page_title -->
			<!-- sd2_con_margin, sd2_con_padding -->
			<div class="sd2_con_margin sd2_con_padding sd2_pb_0">
				<ul class="sd2_link_list sd2_line">
					<li class="sd2_gray sd2_w100">
						<a href="#" class="sd2_list_download_btn">
							<div class="sd2_link_item">
								InAppContent.zip (22.02MB)
								<span class="sd2_down"></span>
							</div>
						</a>
					</li>
				</ul>
			</div><!-- //sd2_con_margin, sd2_con_padding -->
			<!-- sd2_guide_wrap -->
			<div class="sd2_guide_wrap sd2_con_margin sd2_con_padding sd2_pb_0">
				<h4 class="sd2_body_min_title1">About This Document</h4>
				<p class="sd2_paragraph01">This article is an exploratory note to the InAppContent sample application. The InAppContent sample application is intended to present possible usage of the Samsung In-App Purchase Library in an application written in the client-server model.</p>
				<p class="sd2_paragraph01 sd2_mb_40">The Samsung In-App Purchase Library is also called Plasma or the Plasma Library. We will use the shorter, Plasma throughout this document.</p>
				<h5 class="sd2_body_min_title2 sd2_mt_0">Prerequisites</h5>
				<p class="sd2_paragraph01">In order to take advantage of this developer guide you should already have an intermediate knowledge of the Android SDK, a basic knowledge of the Servlet API and/or Google App Engine using Java (e.g. the level enough to be able to write a simple web application using Google App Engine).</p>
				<p class="sd2_paragraph01 sd2_mb_40">As this is not an introductory tutorial, some initial knowledge of Samsung In-App Purchase library is also needed. If you do not meet this requirement please read The Plasma Programming Guide which can be obtained as PDF on <a href="http://developer.samsung.com/android/tools-sdks/In-App-Purchase-Library" target="_blank" class="sd2_link_go">http://developer.samsung.com/android/tools-sdks/In-App-Purchase-Library</a> web page. It is also recommended to complete one of the introductory tutorials linked from that page (for example: <a href="http://developer.samsung.com/android/technical-docs/In-App-Purchase-using-Plasma-in-Android" target="_blank" class="sd2_link_go">http://developer.samsung.com/android/technical-docs/In-App-Purchase-using-Plasma-in-Android</a>).</p>
				<h5 class="sd2_body_min_title2 sd2_mt_0">Attachments</h5>
				<p class="sd2_paragraph01">This article comes with two eclipse projects. One for an Android Application and one for the server side web application. These are /InAppContentAndroid and /InAppContentServer accordingly. You can import them by selecting File > Import… from the Eclipse menu and then on the dialog selecting General > Existing Projects into Workspace.</p>
				<p class="sd2_paragraph01">You should have installed the Android SDK Tools r21.1 and Eclipse ADT Plugin 21.1.0 to work with the Android Project. They both can be obtained from <a href="http://developer.android.com/sdk/index.html" target="_blank" class="sd2_link_go">http://developer.android.com/sdk/index.html</a>. To work with the server side project you should have the Google Plugin for Eclipse, appropriate to your Eclipse version installed on your computer. If you do not have it you may download it from <a href="https://developers.google.com/eclipse/docs/getting_started" target="_blank" class="go">https://developers.google.com/eclipse/docs/getting_started</a>.</p>
				<p class="sd2_paragraph01 sd2_mb_0">Additionally, the server side code utilizes the Jackson JSON parsing library, which should be downloaded separately from <a href="http://jackson.codehaus.org/1.9.11/jackson-all-1.9.11.jar" target="_blank" class="sd2_link_go">http://jackson.codehaus.org/1.9.11/jackson-all-1.9.11.jar and put into the InAppContentServer/war/WEB-INF/lib folder</a>.</p>
			</div><!-- //sd2_guide_wrap -->
			<!-- sd2_guide_wrap -->
			<div class="sd2_guide_wrap sd2_con_margin sd2_con_padding sd2_pb_0">
				<h4 class="sd2_body_min_title1">The Application Logic</h4>
				<p class="sd2_paragraph01">The application comprises of two main parts – an Android client application and a Java web application.</p>
				<p class="sd2_paragraph01 sd2_mb_30">The client application is a reader which allows a user to read content delivered by the server. The Server can serve both paid and free of charge content pages. The access to paid content is granted based on “access tickets”, which are virtual items purchased using the Samsung In-App Purchase Library. The content pages are simple HTML pages and the client app uses WebView component to render them. The server knows if the specific client application has permission to access the requested page based on the custom HTTP headers which incorporate the proper “access ticket’s” item id and purchase id. The item id and purchase id are properties of “access ticket” items defined in the Samsung In-App Purchase service. To avoid hitting the database on each request the server sets a short-time session cookie, which is then recognized when the other client’s requests tries to access content bound to the same item id. This part of the application’s functionality is illustrated on Scheme 1.</p>
				<!-- img_c -->
				<div class="sd2_img_c sd2_mb_30">
					<img src="/images/services/content/img_in_app_cnt_01.gif" width="627" height="440" alt="[Scheme 1]" />
					<p class="sd2_figure">[Scheme 1]</p>
				</div><!-- //img_c -->
				<p class="sd2_paragraph01">In case the user has no valid “access ticket” for the requested content, a servlet filter dispatches the request to an “access denied” page, which is an HTML page containing a button to buy a proper ticket in the application. This button works with use of the “JavascriptInterface feature” of the WebView component. A user may also navigate to the activity which enables the purchase of “access tickets” by selecting the “Items List” entry from the options menu.</p>
				<p class="sd2_paragraph01">Buying a ticket is done with use of Samsung In-App Purchase Library. To take advantage of this library the developer should have registered a seller account on the Samsung Apps web site. The library enables to sell “virtual items” in an Android application with very little effort. It takes over most of the work from the developer, such as authenticating users, handling payments (with different methods) and even showing dialogs to its users. The only thing left to do in the application is to register the appropriate listener and handle purchase events accordingly.</p>
				<p class="sd2_paragraph01 sd2_mb_30">In the described application the server needs to have reliable information that the user actually bought the item, which he claims (with the request’s header) he did. After the ticket has been purchased, it must be verified by the server before it can be used to access specific content. The Plasma library also comes with an easy, out-of-the-box, solution for such verification. During the purchase operation, Plasma generates a verification URL and params, which the client application later sends to the server application, which in turn sends as a request to the verification URL on the Samsung Apps server. After having verified the ticket the server application stores it for later use. This part of application’s functionality is illustrated on Scheme 2.</p>
				<!-- img_c -->
				<div class="sd2_img_c sd2_mb_30">
					<img src="/images/services/content/img_in_app_cnt_02.gif" width="613" height="456" alt="[Scheme 2]" />
					<p class="sd2_figure">[Scheme 2]</p>
				</div><!-- //img_c -->
				<p class="sd2_paragraph01 sd2_mb_0">Caution: As the payment id value for a specific item is passed from the client application using custom HTTP headers, enabling SSL for paid content requests is then crucial. This applies to verification requests, too.</p>
			</div><!-- //sd2_guide_wrap -->
			<!-- sd2_guide_wrap -->
			<div class="sd2_guide_wrap sd2_con_margin sd2_con_padding sd2_pb_0">
				<h4 class="sd2_body_min_title1">Samsung In-App Purchase Setup</h4>
				<p class="sd2_paragraph01">In order to use the Samsung In-App Purchase Library in your application, two conditions must be satisfied:</p>
				<ul class="sd2_con_list sd2_oneline">
					<li><p>A developer must have a seller’s account on the Samsung Apps server.</p></li>
					<li><p>The android client application which uses the Plasma library should run on a device with the Samsung Apps application installed. In order to purchase items a user has to have an account on the Samsung Apps server.</p></li>
				</ul>
				<p class="sd2_paragraph01">If you do not have a seller’s account you can create a new one at - <a href="http://seller.samsungapps.com" target="_blank" class="go">http://seller.samsungapps.com</a>.</p>
				<p class="sd2_paragraph01 sd2_mb_30">Log in into your seller account on the Samsung Apps server and navigate to Applications > Item. There you can define a group of items (see Screen 1).</p>
				<!-- img_c -->
				<div class="sd2_img_c sd2_mb_30">
					<img src="/images/services/content/img_in_app_sc_01.gif" width="640" height="283" alt="[Screen 1]" />
					<p class="sd2_figure">[Screen 1]</p>
				</div><!-- //img_c -->
				<p class="sd2_paragraph01">A group is a “virtual bag of items”. You will use its id in your application to tell the Samsung In-App Purchase Library which items (e.g.: items of which group) your application offers to its users.</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<!--<input type="checkbox" name="show_line_1" id="show_line_1" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_1">Show Lines</label>-->
					<pre class="line-numbers"><code class="language-java">public static final String PLASMA_ITEM_GROUP_ID = "100000031512";</code></pre>
					<p class="sd2_figure">[Code 1]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01">The InAppContent sample application uses the item group id as above.</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<!--<input type="checkbox" name="show_line_2" id="show_line_2" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_2">Show Lines</label>-->
					<pre class="line-numbers"><code class="language-java">mPlasma = new Plasma(PLASMA_ITEM_GROUP_ID, this);</code></pre>
					<p class="sd2_figure">[Code 2]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01">In your application, you use the group id to create a Plasma object. The Plasma object is a “bridge” between your application and the Samsung Apps application. The Samsung Apps application in turn communicates with the Samsung Apps server. But this is not important to you, as in your application code you use only a Plasma object to handle purchase related issues, and do not need to bother about the actual implementation details.</p>
				<p class="sd2_paragraph01">After creating a group, click on its name to add items to it. You will be taken to the page as on the Screen 2, where you can define “virtual items” which than your application will sell to its users.</p>
				<p class="sd2_paragraph01 sd2_mb_30">As you see on Screen 2, there are already four items defined in group, used by the InAppContent sample application.</p>
				<!-- img_c -->
				<div class="sd2_img_c sd2_mb_0">
					<img src="/images/services/content/img_in_app_sc_02.gif" width="627" height="556" alt="[Screen 2]" />
					<p class="sd2_figure">[Screen 2]</p>
				</div><!-- //img_c -->
			</div><!-- //sd2_guide_wrap -->
			<!-- sd2_guide_wrap -->
			<div class="sd2_guide_wrap sd2_con_margin sd2_con_padding sd2_pb_0">
				<h4 class="sd2_body_min_title1">The Android Client</h4>
				<p class="sd2_paragraph01">The entry point class of the client application is ContentReaderActivity. This activity works as a browser for viewing the server side content. It also adds custom request headers to inform the server side application of all non-expired, verified “access tickets” items the client has. The server decides upon these headers if the client is authorized to access requested content page.</p>
				<p class="sd2_paragraph01">A user can also navigate from the options menu to the two remaining “top level” activities: the ItemsListActivity and the PurchaseHistoryActivity. There is also a service which sends the newly purchased ticket to the server.</p>
				<p class="sd2_paragraph01">The ItemsListActivity displays a list of “access ticket” items from Samsung In-App Purchase service. From there, a user gets to the activity which allows purchasing a new item. Also the activities for managing locally stored tickets can be reached from there.</p>
				<p class="sd2_paragraph01 sd2_mb_40">The PurchaseHistoryActivity lists all items bought by current Samsung Apps user for the group id which used by this application.</p>
				<h5 class="sd2_body_min_title2 sd2_mt_0">Local database</h5>
				<p class="sd2_paragraph01">The local database consists of only one table whose rows correspond to the AccessTicket class properties. You may wonder why local persistence is needed at all, while the purchased items can be fetched directly from the Plasma object. First of all, the AccesTicket class also contains some additional information describing server side status (such as “expired” or “verified”) of the “access ticket” item. It also stores a verification URL and params (which cannot be retrieved from the library’s PurchasedItemInformation object after purchasing operation has been finished). Another reason is that although the Plasma object allows iterating over all purchased items, it does not offer more precise query methods.</p>
				<p class="sd2_paragraph01 sd2_mb_40">All operations on the local database are performed with use of the AccessTicketDbHelper class.</p>
				<h5 class="sd2_body_min_title2 sd2_mt_0">Browsing Content</h5>
				<p class="sd2_paragraph01">Browsing the server content is done exclusively by the ContentReaderActivity class. In fact it uses WebView for browsing pages and simply intercepts the WebViews’s requests (by providing a custom WebViewClient implementation) to add a custom header listing, to all non-expired, verified “access ticket” in format as below.</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<!--<input type="checkbox" name="show_line_3" id="show_line_3" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_3">Show Lines</label>-->
					<pre class="line-numbers"><code class="language-java">X-Item-&lt;ITEM_ID&gt;: &lt;PURCHASE_ID&gt;</code></pre>
					<p class="sd2_figure">[Code 3]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01">This is enough for the server to know if the client application has bought an item entitling to access the particular page. The activity does not need to know the “site-map” of pages hosted on the server, nor which “access ticket” item is required to access a particular page. The only information that is hard coded into the client application is the URL of the start page.</p>
				<p class="sd2_paragraph01">The activity exposes two @JavascriptInterface methods to the WebView. These methods are used by the accessdenied.jsp page. The accessdenied.jsp page is returned from the server when a user tries to access a page for which the client application does not have a valid “access ticket” item.</p>
				<ul class="sd2_con_list sd2_oneline">
					<li><p>The requestPurchaseItem(String itemId) method simply brings the user to the BuyTicketItemActivity. The accessdenied.jsp contains a button whose onclick listener invokes this method with the item id of the “access ticket” required to access the blocked page.</p></li>
					<li><p>The notifyItemExpired(String paymentId) updates an entry in the database table matching given paymentId setting its status to AccessTicket.SERVER_STATUS_EXPIRED. This is invoked automatically when the page is loaded into WebView in case the denial was caused by just expired ticket.</p></li>
				</ul>
				<p class="sd2_paragraph01">The ContentReaderActivity also registers receiver which is invoked when a new “access ticket” has been purchased or removed due to its expiration. When invoked it prepares fresh list of custom headers which are attached to each request conceived by the WebView.</p>
				<p class="sd2_paragraph01">The outline of this class is presented below.</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_4" id="show_line_4" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_4">Show Lines</label>
					<pre class="line-numbers"><code class="language-java">public class ContentReaderActivity extends CommonBaseActivity {
//...

	private final WebViewClient mWebViewClient = new WebViewClient() {

		@Override
		public boolean shouldOverrideUrlLoading(WebView view, String url) {
		if(url.startsWith(SERVER_AUTHORITY)) {
		loadUrlWithAccessHeaders(url);
		return true;
		}
		startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url)));
		return true;
		}

		@Override
		public void onPageFinished(WebView view, String url) {
		if(mBlockAlert != null) {
		mBlockAlert.dismiss();
		mBlockAlert = null;
		}
		}

		@JavascriptInterface
		public void requestPurchaseItem(String itemId) {
		startBuyItemTicketActivity(ContentReaderActivity.this, itemId);
		}

		@JavascriptInterface
		public void notifyItemExpired(String paymentId) {
		setExpiredAndRefreshAccessHeadersAsync(paymentId);
		}
	};

	//...

	@SuppressLint("SetJavaScriptEnabled")
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_content_reader);
		CookieManager.getInstance().setAcceptCookie(true);
		mWebView = (WebView) findViewById(R.id.webView);
		mWebView.getSettings().setJavaScriptEnabled(true);
		mWebView.getSettings().setCacheMode(WebSettings.LOAD_DEFAULT);
		mWebView.getSettings().setUserAgentString(USER_AGENT_CONTENT_READER);
		mWebView.addJavascriptInterface(mWebViewClient, JS_INTERFACE_NAME);
		mWebView.setWebViewClient(mWebViewClient);
		refreshAccessHeadersAsyncAndLoad(START_PAGE_URL);
		registerReceiver(mReceiver, sIntentFilter);
	}

	//...

	void loadUrlWithAccessHeaders(String url) {
		mBlockAlert = showBlockAlert(getString(R.string.wait),
			getString(R.string.loading_url, url));
		mWebView.loadUrl(url, mAccessTicketHeaders);
	}

	//...
	}</code></pre>
					<p class="sd2_figure">[Code 3]</p>
				</div><!-- //sd2_code_wrap -->
				<h5 class="sd2_body_min_title2 sd2_mt_0">Purchasing A New “Access Ticket” Item</h5>
				<p class="sd2_paragraph01">Purchasing ticket is a two step process which is conducted by three components together: the BuyTicketItemActivity, the AccessTicketVerificationService and the AccessTicketActivity.</p>
				<p class="sd2_paragraph01">The process starts in the BuyTicketItemActivity, which the user use can reach either by clicking a button in the accessdenied.jsp page or by navigating from the options menu to ItemsListActivity and then choosing the item to buy from a list of items.</p>
				<p class="sd2_paragraph01">In the BuyTicketItemActivity a user may buy a new “access ticket” for the given item id, only if there are no other valid tickets for the same item id (if there are any, a user can jump to AccessTicketsActivity to manage tickets associated with this item id – see section Managing “Access Tickets”).</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<!--<input type="checkbox" name="show_line_5" id="show_line_5" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_5">Show Lines</label>-->
					<pre class="line-numbers"><code class="language-java">void purchaseItem() {
		if(!getPlasma().requestPurchaseItem(mPlasmaTransactionId++, mItemId)) {
			//show error alert
		}
	}</code></pre>
					<p class="sd2_figure">[Code 5]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0">A ticket is bought in Samsung In-App Purchase service using a Plasma object.</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_6" id="show_line_6" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_6">Show Lines</label>
					<pre class="line-numbers"><code class="language-java">mPlasma.setPlasmaListener(new PlasmaListener() {

//...

	@Override
	public void onPurchaseItemFinished(int transactionId, int statusCode,
	PurchasedItemInformation purchasedItemInformation) {
		if(statusCode == Plasma.STATUS_CODE_SUCCESS) {
			PurchaseTicket purchaseTicket = mTicketToBeSent;
			if(purchaseTicket == null) {
			//show error alert
		}
		else {
			mTicketToBeSent = null;
			saveTicketAsync(purchaseTicket,
			purchasedItemInformation);
			}
		}
		else {
			//show error alert
		}
	}

	@Override
	public void onPurchaseItemInitialized(int transactionId, int statusCode,
		PurchaseTicket purchaseTicket) {
		if(statusCode == Plasma.STATUS_CODE_SUCCESS) {
			mTicketToBeSent = purchaseTicket;
		}
		else {
			//show error alert
		}
	}
});</code></pre>
					<p class="sd2_figure">[Code 6]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0">The registered PlasmaListener’s onPurchaseItemInitialized method stores provided PurchaseTicket objects for later use. Then in the onPurchaseItemFinished method a new access ticket entry in the database table is created based on the information retrieved both from PurchaseTicket and PurchasedItemInformation objects.</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_7" id="show_line_7" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_7">Show Lines</label>
					<pre class="line-numbers"><code class="language-java">void saveTicketAsync(final PurchaseTicket purchaseTicket,
		final PurchasedItemInformation purchasedItemInformation) {

	new DbQueryTask<Object, Exception>(R.string.wait,
	R.string.wait_saving_ticket) {

		@Override
		protected Exception firstHitDatabaseInWorkerThread(
		AccessTicketDbHelper dbHelper, Object... params) {
			try {
				ContentValues contentValues =
				AccessTicket.getTicketValues(
					(PurchaseTicket) params[0],
					(PurchasedItemInformation) params[1]);
				long insertedId =
				getDbHelper().insertNewTicket(contentValues);
				if(-1 == insertedId) {
					throw new IllegalStateException(
					"No item inserted into database");
				}
			}
			catch (Exception e) {
				return e;
			}
			return null;
		}

		@Override
		protected void thenTakeUseOfItBackOnUiThread(Exception error) {
			if(error == null) {
				//Ask user with Dialog if he wants to verify ticket
				//now or later. If now redirect to AccessTicketActivity
			}
			else {
				//show error alert
			}
		}
	}.execute(purchaseTicket, purchasedItemInformation);
}</code></pre>
					<p class="sd2_figure">[Code 7]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0">After the ticket is successfully purchased with the In-App Purchase library and saved into the local database, it is time to send it to the server. The user is asked with a Dialog if he or she wants to do it immediately or leave it for later moment (possibly because of temporarily unstable network connection). If the user wants to send the ticket for verification on the server he or she is redirected to the AccessTicketActivity. The goal for adding this additional activity is to provide a “navigation point” to which a user could come back later if verification failed or when he or she postponed it intentionally. The activity is started with an intent with a data URI from which a particular purchase id can be retrieved (this purchase id identifies a particular AccessTicket row in the local database). With this activity the user can manage particular AccessTicket entry in the local database, not only verify a new ticket but also remove an old expired ticket. However, because consistency between client and server applications is very important, the activity does not send verification requests on its own but starts a service to this job, and waits until it broadcasts the result of the operation.</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_8" id="show_line_8" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_8">Show Lines</label>
					<pre class="line-numbers"><code class="language-java">public class AccessTicketVerificationService extends Service {
//...

private class VerificationRequestRunnable implements Runnable {

	//...

	@Override
	public void run() {
		AccessTicket accessTicket = null;
		try {
			accessTicket = getDbHelper().getTicketByPaymentId(
				mPaymentId);
			}
		}
		catch (Exception e) {
			//...
		}
		AndroidHttpClient httpClient = AndroidHttpClient.newInstance(
		USER_AGENT_TICKET_SERVICE);
		String responseText = null;
		try {
			responseText = parseResponse(httpClient.execute(
			prepareRequest(accessTicket)));
		}
		catch (Exception e) {
			//...
		}
		finally {
			httpClient.close();
		}

		//...

		try {
			if(SERVER_RESPONSE_VERIFIED.equalsIgnoreCase(
			responseText)) {
				getDbHelper().updateTicketStatus(mPaymentId,
				AccessTicket.SERVER_STATUS_OK);
				exit(mPaymentId, Status.VERIFIED, null);
			}
			else if(SERVER_RESPONSE_REJECTED.equalsIgnoreCase(
				responseText)) {
				getDbHelper().updateTicketStatus(mPaymentId,
				AccessTicket.SERVER_STATUS_REJECTED);
			exit(mPaymentId, Status.REJECTED, null);
			}
			else {
				getDbHelper().updateTicketStatus(mPaymentId,
				AccessTicket.SERVER_STATUS_ERROR);
				exit(mPaymentId, Status.SERVER_SIDE_ERROR,
				"Server response: " + responseText);
			}
		}
		catch (Exception e) {
			//...
		}
	}
}

//...

HttpUriRequest prepareRequest(AccessTicket accessTicket) throws
UnsupportedEncodingException, JSONException {
	HttpPost request = new HttpPost(SERVER_VERIFICATION_URL);
	request.setHeader("Accept", "text/plain");
	request.setHeader("Content-Type",
	"application/x-www-form-urlencoded");
	request.setEntity(new UrlEncodedFormEntity(
		accessTicket.asRequestParameters(), HTTP.UTF_8));
	return request;
}

//...

}

public class AccessTicket implements BaseColumns {

//...

public List&lt;NameValuePair&gt; asRequestParameters() {
	List&lt;NameValuePair&gt; parameters = new ArrayList&lt;NameValuePair&gt;();
	parameters.add(new BasicNameValuePair(QUERY_PARAM_ITEM_ID, itemId));
	parameters.add(new BasicNameValuePair(QUERY_PARAM_PARAM_1, param1));
	parameters.add(new BasicNameValuePair(QUERY_PARAM_PARAM_2, param2));
	parameters.add(new BasicNameValuePair(QUERY_PARAM_PARAM_3, param3));
	parameters.add(new BasicNameValuePair(QUERY_PARAM_PAYMENT_ID, paymentId));
	parameters.add(new BasicNameValuePair(QUERY_PARAM_PURCHASE_ID, purchaseId));
	parameters.add(new BasicNameValuePair(QUERY_PARAM_VERIFY_URL, verifyUrl));
	return parameters;
}

//...
}</code></pre>
					<p class="sd2_figure">[Code 8]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0 sd2_mb_40">The AccessTicketVerificationService sends a request to the server side application which in turn verifies the reported transaction on the Samsung Apps server. Finally the service updates the status of the verified AccessTicket in the local database, upon a server response with the status of the operation. From now on, a successfully verified “access ticket” item can be used by a client application to access paid content pages.</p>
				<h5 class="sd2_body_min_title2 sd2_mt_0">Managing “Access Tickets”</h5>
				<p class="sd2_paragraph01">Managing tickets, addresses two actions: removal and verification. A user can browse purchased “access tickets” in two ways.</p>
				<p class="sd2_paragraph01">A user can browse all “access ticket” items ever bought by selecting “Purchase History” from the options menu. This brings the user to the PurchaseHistoryActivity. This activity simply lists all purchased items associated to a user account in the Samsung In-App Purchase service for the group id which the application uses. The activity loads items by portions using the Loading List Library, which has been introduced in the Batch Loading List Examples developer guide, which can be found on the Samsung Developers web site. Selecting a particular item from the list brings the user to the AccessTicketActivity opened for the given purchase id, where, if the corresponding row for a given purchase id exists in the local database, a user can remove the given “access ticket” or verify an unverified “access ticket” as described in the previous section.</p>
				<p class="sd2_paragraph01">The user can also browse “access tickets” by item category. To do that, they must select the “Items List” from the options menu which opens the ItemsListActivity. This activity lists all items defined in the Samsung In-App Purchase service for the group id used by the application. Selecting one of the displayed items, moves the user to the AccessTicketsActivity, listing all tickets stored in the local database for the given item id (which is retrieved from the intent which started this activity). The activity also enables filtering “access tickets” by its status value (for example: “verified” or “expired”). Selecting a particular item moves the user to the AccessTicketActivity (which was already described in the previous section) which is opened for specific AccessTicket identified by the purchase id.</p>
				<p class="sd2_paragraph01 sd2_mb_0">Notice that the elements listed in AccessTicketsActivity and PurchaseHistoryActivity are not of the same “type”. The difference is subtle but important. The AccessTicketsActivity lists all entries which exist in the local database. These are used by the application and contain some additional information specific to the application and not provided by the Samsung In-App Purchase service such as expiration status. Also removing an access ticket means removing the entry from the local database. On the other hand the PurchaseHistoryActivity lists purchased items managed by the Samsung In-App Purchase service. These cannot be removed by the user and there is no guarantee that the corresponding row in a client’s local database exists (either due to explicit removal by the user or due to an error). They can be thought of as the history track of transactions.</p>
			</div><!-- //sd2_guide_wrap -->
			<!-- sd2_guide_wrap -->
			<div class="sd2_guide_wrap sd2_con_margin sd2_con_padding sd2_pb_0">
				<h4 class="sd2_body_min_title1">The Server Side</h4>
				<p class="sd2_paragraph01 sd2_mb_30">The server side part of the project is a Java web application as specified by the Servlet API. It also uses a Java Persistence API for database storage. To make deployment easy it has been developed as a Google AppEngine Java web application. However it does not use any GAE features which are incompatible with above mentioned standard APIs. Thus, it should be eligible for deployment in any servlet container and JPA provider with only a few configuration changes. No adjustments in java code should be necessary. In most cases the configuration changes will be limited to setting a different persistence provider and provider specific properties in the /src/META-INF/persistence.xml descriptor file. Another important configuration job is to enable SSL. As it has been said before, enabling SSL for paid content requests is crucial as the payment id for specific items is passed from the client application with use of custom HTTP headers. Enabling SSL in a web server is a vendor specific issue not a part of any standard specification.</p>
				<h5 class="sd2_body_min_title2 sd2_mt_0">Enabling SSL in Google App Engine Web Application</h5>
				<p class="sd2_paragraph01">Enabling SSL in Google App Engine web application is very simple. In /war/WEB-INF/appengine-web.xml add &lt;ssl-enabled&gt;true&lt;/ssl-enabled&gt; somewhere inside the appengine-web-app node. This is setting a “vendor specific” (as the appengine-web.xml descriptor is vendor specific, too).</p>
				<p class="sd2_paragraph01 sd2_mb_20">Next to vendor specific settings a standard security-constraint is set in web.xml descriptor file.</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_9" id="show_line_9" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_9">Show Lines</label>
					<pre class="line-numbers"><code class="language-markup">&lt;security-constraint&gt;
	&lt;web-resource-collection&gt;
		&lt;web-resource-name&gt;Secure&lt;/web-resource-name&gt;
		&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
	&lt;/web-resource-collection&gt;
	&lt;user-data-constraint&gt;
		&lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
	&lt;/user-data-constraint&gt;
&lt;/security-constraint&gt;</code></pre>
					<p class="sd2_figure">[Code 9]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0 sd2_mb_30">This is a standard setting specified by the Servlet API and it should be left untouched when deployed to other environments than GAE.</p>
				<h5 class="sd2_body_min_title2 sd2_mt_0">Project Overview</h5>
				<p class="sd2_paragraph01">The server side part of the application is pretty straightforward. Basically it consists of three main parts:</p>
				<ul class="sd2_con_list sd2_oneline">
					<li><p>A simple servlet which is an endpoint for verification requests from client applications.</p></li>
					<li><p>A simple servlet filter which attaches to requests for paid content pages.</p></li>
					<li><p>Two entity classes and a utility class for performing database operations which are used by the two former components.</p></li>
				</ul>
				<p class="sd2_paragraph01">All these classes are in the com.sprc.example.inappcontent.server package. Under the /src directory you can see another package com.sprc.example.inappcontent.shared with the SharedConstants class which contains constants used by both the client and the server and which you already know from the Android client application description.</p>
				<p class="sd2_paragraph01 sd2_mb_30">There is still one important thing to mention. Basically a “content page” can be any resource on the server, from static HTML pages to dynamic content generated by a servlet, as long as its servlet path matches url-mapping for AccessFilter instance. However, the Google App Engine ignores filter mappings pointing at static resources, so in this hosting environment JSP files must be used instead of plain HTML files.</p>
				<h5 class="sd2_body_min_title2 sd2_mt_0">Persistent Entities</h5>
				<p class="sd2_paragraph01">The server must keep the information about purchased tickets to be able to distinguish legal and illegal requests. The JPA standard is used for persistence. The base entity class is VerifiedTicket. It is a simple bean which stores mainly data about purchased item obtained from responses to the verification request sent to the Samsung Apps server. Next to this data it has two more properties registrationTimestamp and expirationTimestamp, which are used for some local bookkeeping. The registrationTimestamp is set when the entity is saved for the first time. The expirationTimestamp is set when the entity is used for the first time. Its value is evaluated according to the current timestamp and the corresponding init-param defined in web.xml (see section “The AccessFilter class”).</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_10" id="show_line_10" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_10">Show Lines</label>
					<pre class="line-numbers"><code class="language-java">@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
@Access(AccessType.FIELD)
public class VerifiedTicket {

	@Id
	String paymentId;

	Double paymentAmount;

	String itemName;

	String itemDesc;

	@Column(nullable = false)
	@Basic(optional = false)
	String itemId;

	@Column(nullable = false)
	@Basic(optional = false)
	@Temporal(TemporalType.TIMESTAMP)
	Date purchaseDate;

	@Column(nullable = false)
	long registrationTimestamp;

	@Column(nullable = true)
	@Basic(optional = true)
	Long expirationTimestamp;

	//...
}</code></pre>
					<p class="sd2_figure">[Code 10]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0">Once the ticket has expired it is moved to another database table for historic data. This table is associated with the ExpiredTicket entity which extends VerifiedTicket and basically is a copy of it. This is why the supertype was annotated with @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS). Creating an additional table for used tickets is reasonable as queries for valid tickets are performed much more frequently.</p>
				<p class="sd2_paragraph01 sd2_mb_30">The other classes access persistent data with use of the EntityManagerUtil class, which stores an instance of EntityManagerFactory. It defines also some common query methods.</p>
				<h5 class="sd2_body_min_title2 sd2_mt_0">The AccessFilter class</h5>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_11" id="show_line_11" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_11">Show Lines</label>
					<pre class="line-numbers"><code class="language-markup">&lt;filter&gt;
	&lt;filter-name&gt;Area1&lt;/filter-name&gt;
	&lt;filter-class&gt;com.sprc.example.inappcontent.server.AccessFilter&lt;/filter-class&gt;
	&lt;init-param&gt;
		&lt;param-name&gt;itemId&lt;/param-name&gt;
		&lt;param-value&gt;000000063849&lt;/param-value&gt;
	&lt;/init-param&gt;
	&lt;init-param&gt;
		&lt;param-name&gt;itemName&lt;/param-name&gt;
		&lt;param-value&gt;Access Ticket Area 1&lt;/param-value&gt;
	&lt;/init-param&gt;
	&lt;init-param&gt;
		&lt;param-name&gt;cookieMaxAgeSeconds&lt;/param-name&gt;
		&lt;param-value&gt;3600&lt;/param-value&gt;
	&lt;/init-param&gt;
	&lt;init-param&gt;
		&lt;param-name&gt;ticketExpirationHours&lt;/param-name&gt;
		&lt;param-value&gt;12&lt;/param-value&gt;
	&lt;/init-param&gt;
&lt;/filter&gt;</code></pre>
					<p class="sd2_figure">[Code 11]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0">Each filter instance requires four init-params:</p>
				<ul class="sd2_con_list sd2_oneline">
					<li><p>itemId – this is the item id defined in the Samsung App Seller’s account.</p></li>
					<li><p>itemName – the name of item which will be displayed to user when redirected to the accessdenied page. This should be the same as the name defined for the item in the Samsung Apps Seller’s account.</p></li>
					<li><p>cookieMaxAgeSeconds – tells how long in seconds a session cookie set by this filter is valid.</p></li>
					<li><p>ticketExpirationHours – tells how long in hours the ticket can be used for accessing paid content. The time for each specific ticket is measured from when it was first used.</p></li>
				</ul>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_12" id="show_line_12" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_12">Show Lines</label>
					<pre class="line-numbers"><code class="language-markup">&lt;filter-mapping&gt;
	&lt;filter-name&gt;Area1&lt;/filter-name&gt;
	&lt;url-pattern&gt;/area1/*&lt;/url-pattern&gt;
	&lt;url-pattern&gt;/file_in_other_location.jsp&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre>
					<p class="sd2_figure">[Code 12]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0">The filter-mapping entry links pages which require purchasing to an “access ticket” item with the filter instance having a corresponding itemId init-param.</p>
				<p class="sd2_paragraph01">To understand how this filter works let’s step through its doFilter method body.</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_13" id="show_line_13" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_13">Show Lines</label>
					<pre class="line-numbers"><code class="language-java">@Override
public void doFilter(ServletRequest req, ServletResponse resp,
	FilterChain chain) throws IOException, ServletException {

EntityManager entityManager = createEntityManager();</code></pre>
					<p class="sd2_figure">[Code 13]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01">First it creates the entity manager which will be used for database queries. The createEntityManager() method is imported from the EntityManagerUtil with import static clause (the same applies to the database access methods which you will come across some lines later).</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<!--<input type="checkbox" name="show_line_14" id="show_line_14" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_14">Show Lines</label>-->
					<pre class="line-numbers"><code class="language-java">Config conf = getConfig();</code></pre>
					<p class="sd2_figure">[Code 14]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01">Then the Config object is obtained. This object is a bag of final values retrieved from init-params. (The aim of this object is to decrease number of synchronized blocks).</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<!--<input type="checkbox" name="show_line_15" id="show_line_15" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_15">Show Lines</label>-->
					<pre class="line-numbers"><code class="language-java">HttpServletRequest httpRequest = (HttpServletRequest) req;
if(hasPermissionCookie(httpRequest, conf.mTicketItemId)) {
	chain.doFilter(req, resp);
	return;
}</code></pre>
					<p class="sd2_figure">[Code 15]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0">If the request has a valid cookie set by this filter it just calls doFilter on FilterChain to fetch requested page. However if it does not, a deeper test including a database hit is needed.</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_16" id="show_line_16" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_16">Show Lines</label>
					<pre class="line-numbers"><code class="language-java">String accessTicketHeaderName = SharedConstants.X_ITEM_HEADER_PREFIX +
	conf.mTicketItemId;
String accessHeaderValue = httpRequest.getHeader(accessTicketHeaderName);
if(accessHeaderValue != null) {
	VerifiedTicket ticket = getTicketById(entityManager,
	accessHeaderValue);
	if(ticket != null && ticket.getItemId().equals(conf.mTicketItemId)) {
		if(ticket.getExpirationTimestamp() == null) {
			updateExpirationTimestamp(entityManager, ticket,
			ticket.getRegistrationTimestamp() +
			conf.mTicketExpirationMillis);
		}</code></pre>
					<p class="sd2_figure">[Code 16]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0">If the ticket is used for the first time the filter sets an expiration time according to the proper init-param from the web.xml. After that it updates the entry in the database.</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_17" id="show_line_17" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_17">Show Lines</label>
					<pre class="line-numbers"><code class="language-java">if(ticket.getExpirationTimestamp() <
	System.currentTimeMillis()) {
		moveToExpiredTable(entityManager, ticket);
		req.setAttribute(ATTRIBUTE_EXPIRED_PAYMENT_ID,
			ticket.getPaymentId());
}
else {
	chain.doFilter(req, resp);
	setPermissionCookie(httpRequest,
		(HttpServletResponse) resp, conf);
	return;
}</code></pre>
					<p class="sd2_figure">[Code 17]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0">If the ticket is expired it is moved from the table with verified tickets to the one with expired tickets. (Notice that the access to the database is done with use of methods imported from the EntityManagerUtil class.) The filter also adds a proper request attribute to tell the “accessdenied” page that it should inform the client application (with JavascriptInterface feature of the WebView component) that this payment id is expired and it should update its status in the client’s local database. Otherwise just let the request reach its target page by calling chain.doFilter(req, resp). In this case the filter also adds a “permission cookie” to the response object in order to avoid hitting the database in the oncoming requests.</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_18" id="show_line_18" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_18">Show Lines</label>
					<pre class="line-numbers"><code class="language-java">  }
}
redirectToBuyTicket(req, resp);</code></pre>
					<p class="sd2_figure">[Code 18]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0 sd2_mb_40">If none of these conditions are fulfilled the request is redirected to the accessdenied page. This page is served with a status 403 Forbidden message. In its HTML it contains the button which triggers buying a proper item on the client application (with use of JavascriptInterface feature of the WebView component).</p>
				<h5 class="sd2_body_min_title2 sd2_mt_0">The TicketVerfificationServlet class</h5>
				<p class="sd2_paragraph01">The TicketVerfificationServlet is responsible for saving information about tickets sent by client applications. The servlet does not require any special initialization in the web.xml descriptor. Let’s follow its doPost method body to understand how it works.</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_19" id="show_line_19" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_19">Show Lines</label>
					<pre class="line-numbers"><code class="language-java">@Override
			protected void doPost(HttpServletRequest req, HttpServletResponse resp)
				throws ServletException, IOException {
			EntityManager entityManager = createEntityManager();</code></pre>
					<p class="sd2_figure">[Code 19]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0">First it creates an EntityManager instance which will be used for queries.</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_20" id="show_line_20" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_20">Show Lines</label>
					<pre class="line-numbers"><code class="language-java">String paymentId = req.getParameter(QUERY_PARAM_PAYMENT_ID);
if(paymentId == null) {
	throw new NullPointerException();
}</code></pre>
					<p class="sd2_figure">[Code 20]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0">Then it gets the payment id from request parameters.</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_21" id="show_line_21" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_21">Show Lines</label>
					<pre class="line-numbers"><code class="language-java">if(verifiedTicketExists(entityManager, paymentId)) show_line_21
	writeResponse(resp, SERVER_RESPONSE_VERIFIED);
	return;
}
if(expiredTicketExists(entityManager, paymentId)) {
	throw new IllegalStateException(
		"Cannot register already used ticket!");
}</code></pre>
					<p class="sd2_figure">[Code 21]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0">After that, it checks if the client application tries to verify an already verified but not expired ticket. When could such a request happen? Possibly when the ticket has been verified, but the former response has not reached the client application. Maybe it was due to a network error? Sending the “verified status response” will not spoil anything but it will enable the client to adjust its local database to reflect the actual state on the server. However, if the payment id corresponds to an already expired ticket, then an exception is thrown.</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_22" id="show_line_22" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_22">Show Lines</label>
					<pre class="line-numbers"><code class="language-java">URL verificationUrl = buildVerificationUrl(req);
String respString = sendVerificationRequest(verificationUrl);
JsonNode jsonNode = parseJson(respString);

if(getStatus(jsonNode)) {
	if(!paymentId.equals(getPaymentId(jsonNode))) {
		throw new IllegalStateException("Invalid verification data!");
	}
	VerifiedTicket verifiedTicket = new VerifiedTicket(jsonNode);
	saveVerifiedTicket(entityManager, verifiedTicket);
	writeResponse(resp, SERVER_RESPONSE_VERIFIED);
}
else {
	writeResponse(resp, SERVER_RESPONSE_REJECTED);
}</code></pre>
					<p class="sd2_figure">[Code 22]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0">It builds the URL to the Samsung Apps server based on parameters sent by the client and sends a request as specified by the URL. The parameters sent by the client are a verification URL and params obtained from Plasma’s PurchaseTicket as specified in the Plasma Programming Guide (see <a href="http://developer.samsung.com/android/tools-sdks/In-App-Purchase-Library" target="_blank" class="go">http://developer.samsung.com/android/tools-sdks/In-App-Purchase-Library</a>). The Samsung Apps server answers with a JSON structure which looks like this:</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_23" id="show_line_23" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_23">Show Lines</label>
					<pre class="line-numbers"><code class="language-java">{"paymentID":"TPMTID201206190000034687","paymentAmount":"1","itemName":"ITM2","item
ID":"000000041131","status":"true","purchaseDate":"2012-06-19
15:13:10","itemDesc":"ITM2"}</code></pre>
					<p class="sd2_figure">[Code 23]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0">Or, in the case of failure, simply like this:</p>
				<!-- sd2_code_wrap -->
				<div class="sd2_code_wrap sd2_mb_30">
					<input type="checkbox" name="show_line_24" id="show_line_24" class="sd2_show_line"><label class="sd2_show_line_label" for="show_line_24">Show Lines</label>
					<pre class="line-numbers"><code class="language-java">{"status": "false"}</code></pre>
					<p class="sd2_figure">[Code 24]</p>
				</div><!-- //sd2_code_wrap -->
				<p class="sd2_paragraph01 sd2_mt_0">If the Samsung Apps server confirmed that the ticket has been purchased then the servlet saves it to the local database and finally sends the “verified status response”. Otherwise the “rejected status response” is sent.</p>
				<p class="sd2_paragraph01">Due to this possibility for verifying purchase operations on the Samsung Apps server developing applications in client-server model with the Plasma Library is also easy. Assuming this feature was lacking, verification of client payments on the server would be bigger challenge.</p>
			</div><!-- //sd2_guide_wrap -->
			<!-- sd2_guide_wrap -->
			<div class="sd2_guide_wrap sd2_con_margin sd2_con_padding sd2_pb_0">
				<h4 class="sd2_body_min_title1">Summary</h4>
				<p class="sd2_paragraph01">This guide provided explanations on how the sample application works and highlighted some of its less obvious parts. We recommend you to read through the sample applications source code to familiarize yourself with the app. Enjoy!</p>
			</div><!-- //sd2_guide_wrap -->
		</div><!-- //substance_wrap -->
	</div><!-- //content_wrap -->
	<!-- ***** IMPORT: sd2_partial_footer ***** -->
	<div id="sd2_partial_footer"></div>
	<!-- //***** IMPORT: sd2_partial_footer ***** -->
</div><!-- //wrap -->
</body>
</html>
